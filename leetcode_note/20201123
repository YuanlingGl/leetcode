Arrays.sort()

Arrays.sort()默认升序不区分大小写 排序 当需要排序的集合或数组不是单纯的数字型时，
通常可以使用Comparator或Comparable，以简单的方式实现对象排序或自定义排序。
此排序被保证是稳定的：不会因调用 sort 方法而对相等的元素进行重新排序。

内部比较器： 需要比较的对象必须实现Comparable接口，并重写compareTo(T o)方法，
表明该对象可以用来排序，否则不能直接使用Arrays.sort()方法。

外部比较器： 需要自己写一个比较器实现Comparator接口，并实现compare(T o1, T o2)方法，
根据自己的需求定义比较规则。使用外部比较器这种方式比较灵活，例如现在需求是按照员工编号和薪资进行排序，
以后可能按照姓名进行排序，这时只要再写一个按照姓名规则比较的比较器就可以了。

AO BO DO PO VO DAO DTO POJO

AO
Application Object 应用对象。
在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。

BO
Business Object 业务对象。
由Service层输出的封装业务逻辑的对象。这个对象可以包括一个或多个其它的对象。
BO描述一个对象的行为和动作，也涉及到基于它的其他对象的一些行为和动作。比如一个“人”的业务逻辑，有睡觉，吃饭，工作，上班等等，还有和别人合作发生的动作。这样处理业务逻辑时，我们就可以针对BO去处理。

DO
Data Object 数据对象。
与数据库表结构一一对应，通过DAO层向上传输数据源对象。

PO
Persistant Object 持久对象。
数据库表中的记录在Java对象中的显示状态。最形象的理解就是一个PO就是数据库中的一条记录。

VO
View Object 显示层对象。
通常是Web向模板渲染引擎层传输的对象。对于一个WEB页面将整个页面的属性封装成一个对象，然后用一个VO对象在控制层与视图层进行传输交换。

DAO
Data Access Object 数据访问对象。
这个和上面几个O区别最大，基本没有互相转化的可能性和必要。主要用来封装对数据库的访问。通过它可以把POJO持久化为DO/PO，用DO/PO组装出来VO、DTO。

DTO
Data Transfer Object 数据传输对象。
DTO是经过处理后的DO/PO，可以增加或者减少PO的属性。
主要用于远程调用等需要大量传输对象的地方。比如一张表有100个字段，那么对应的DO/PO就有100个属性。但是我们界面上只要显示10个字段，客户端在获取数据时，没有必要把整个全部字段传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO 。

POJO
Plain Ordinary Java Object 简单Java对象。
POJO是一种概念或者接口，身份及作用随环境变化而变化。它不包含业务逻辑或持久逻辑等，不具有任何特殊角色，不继承或不实现任何其它Java框架的类或接口。
一个POJO持久化以后就是PO。直接用它传递、传递过程中就是DTO。直接用来对应表示层就是VO。

左模糊
LIKE '%啊'
索引具有B-Tree最左前缀匹配匹配特性，如果左模糊，则无法使用此索引


